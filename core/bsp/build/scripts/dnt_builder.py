# vi: tw=128 ts=3 sw=3 et
# @file dnt_builder.py
# @brief This file contains the API for the Run Control Framework, API 2.1.1
#===============================================================================
# NOTE: The @brief description above does not appear in the PDF.
# The tms_mainpage.dox file contains the group/module descriptions that
# are displayed in the output PDF generated using Doxygen and LaTeX. To
# edit or update any of the group/module text in the PDF, edit the
# tms_mainpage.dox file or contact Tech Pubs.
#===============================================================================
#===============================================================================
# Copyright (c) 2014 Qualcomm Technologies Incorporated.
# All Rights Reserved.
# Qualcomm Confidential and Proprietary.
#===============================================================================
#===============================================================================
# Edit History
# $Header: //components/rel/core.adsp/2.6.1/bsp/build/scripts/dnt_builder.py#1 $
# $DateTime: 2014/10/16 12:45:40 $
# $Change: 6781644 $
# $Author: pwbldsvc $
#===============================================================================

import csv
import os
import fnmatch
from SCons.Script import *
import operator
from operator import itemgetter
from collections import OrderedDict
import inspect

# debug instruments exposed by changing command line as so:
# build.cmd build_target BUILD_VER=00000 --debug=stacktrace --debuginfo=rcinit

#===============================================================================
# Description
#===============================================================================

# This SCONS tool is the build time support for the RCINIT Framework;
# client users to the framework will supply within their software
# delivery at least one call to this tool. The tool includes a number
# of pseudo builder method calls for use by the clients. The input to
# the pseudo builder method calls is used for the final target
# output, an autogenerated C source file.
#
# The tool collates input from PLAYLIST content, and generates a
# PLAYBOOK.
#
# PLAYLIST : Input (eg, SCONS File Metadata, Intermediate Output RCPL)
# SCONS File Metadata optionally is captured as intermediate output
#
# PLAYBOOK : Output (eg, C Source Module)
#
# Includes various warning messages that can be detected at build
# time. The warnings identify potential issues at runtime where the
# software could potentially have issues -- due to name size
# overruns, non-unique string names to the critial length, etc...

#===============================================================================
# Examples
#===============================================================================

# Use Case: Task, REX API Task (RCINIT V1/V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_REX' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exrex',
#   'thread_type'                : 'RCINIT_TASK_REXTASK',
#   'thread_entry'               : 'rcinit_example_rextask',
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER', # aka priority_alias
#   'stack_size_bytes'           : '4096',
#   #'stack_section'             : 'RCINIT_STACK_TASK_RCINIT', # static allocation
#   'cpu_affinity'               : 'REX_ANY_CPU_AFFINITY_MASK',
#   #'policy_optin'              : [ 'default', 'ftm', ], # V2
#  })

# Use Case: Initialization Function (RCINIT V1/V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env:
# env.AddRCInitFunc( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_7',
#   'init_name'                  : 'rcinit_exifn7',
#   'init_function'              : 'rcinit_example_initfn',
#   #'policy_optin'              : [ 'default', 'ftm', ], # V2
#  })

# Use Case: Task, DAL Workloop API (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_DAL' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exdal',
#   'thread_type'                : 'RCINIT_TASK_DALTASK',
#   'thread_entry'               : 'rcinit_example_daltask',
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER', # aka priority_alias
#   'stack_size_bytes'           : '4096',
#   #'stack_section'             : 'RCINIT_STACK_TASK_RCINIT', # static allocation
#   'policy_optin'               : [ 'default', 'ftm', ],
#  })

# Use Case: Task, POSIX Pthread API (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_POSIX' in env:
#  env.AddRCInitTask( # SCONS METADATA PLAYLIST
#   RCINIT_IMG,
#   {
#    'sequence_group'             : 'RCINIT_GROUP_6',
#    'thread_name'                : 'rcinit_expthr',
#    'thread_type'                : 'RCINIT_TASK_POSIX',
#    'thread_entry'               : 'rcinit_example_posix',
#    'priority_amss_order'        : 'RCINIT_PRI_ORDER', # aka priority_alias
#    'stack_size_bytes'           : '4096',
#   #'stack_section'             : 'RCINIT_STACK_TASK_RCINIT', # static allocation
#    'cpu_affinity'               : 'REX_ANY_CPU_AFFINITY_MASK',
#    'policy_optin'               : [ 'default', 'ftm', ],
#   })

# Use Case: Task, QURT Thread API (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env and 'USES_QURT' in env:
# env.AddRCInitTask( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_6',
#   'thread_name'                : 'rcinit_exqurt',
#   'thread_type'                : 'RCINIT_TASK_QURTTASK',
#   'thread_entry'               : 'rcinit_example_qurttask',
#   'priority_amss_order'        : 'RCINIT_PRI_ORDER', # aka priority_alias
#   'stack_size_bytes'           : '4096',
#   #'stack_section'             : 'RCINIT_STACK_TASK_RCINIT', # static allocation
#   'cpu_affinity'               : 'REX_ANY_CPU_AFFINITY_MASK',
#   'policy_optin'               : [ 'default', 'ftm', ],
#  })

# Use Case: Policy Function (RCINIT V2) Playlist Entry
#---------------------------------------------------------------
#
#if 'USES_RCINIT' in env:
# env.AddRCInitPolicy( # SCONS METADATA PLAYLIST
#  RCINIT_IMG,
#  {
#   'sequence_group'             : 'RCINIT_GROUP_3',
#   'policy_name'                : 'DEFAULT_POLICY',
#   'policy_function'            : 'rcinit_example_policyfn',
#   'policy_optin'               : [ 'default', 'ftm', ], # controls tables created
#  })

#===============================================================================
# Installation Notes
#===============================================================================

# IMAGE OWNER TOOL INCLUSION EXAMPLE: THIS CALL IS SUPPLIED IN THE
# IMAGE_ROOT DIRECTORY AS PART OF THE IMAGE SCONS FILE DEFINING THE
# SPECIFIC IMAGE
#---------------------------------------------------------------

#env.InitImageVars(
#   alias_list=aliases, # aliases
#   proc='qdsp6',  # proc
#   config='qdsp6_sw',  # config type, proc_name
#   plat='qurt',
#   target='MODEM_PROC_IMG_${BUILD_ID}', # target (elf, image file name)
#   build_tags = build_tags,
#   deprecated_build_tags = ['CBSP_QDSP6_SW_IMAGE'],
#   tools = ['buildspec_builder.py',
#            '${BUILD_ROOT}/core/bsp/build/scripts/mbn_builder.py',
#            '${BUILD_ROOT}/core/bsp/build/scripts/dnt_builder.py',
#            '${BUILD_ROOT}/core/bsp/build/scripts/devcfg_builder.py',
#            '${BUILD_ROOT}/core/bsp/build/scripts/cmm_builder.py',
#            '${BUILD_ROOT}/core/bsp/build/scripts/swe_builder.py',
#            '${BUILD_ROOT}/core/bsp/build/scripts/sleep_lpr_builder.py']
#   )

#===============================================================================
# Image Owner Notes for PLAYLIST and PLAYBOOK
#===============================================================================
#
# Consult Module RCINIT_PLAYBOOK For Extended Description
#
# NOTE: PLAYBOOK STATIC PRIVATE DATA ITEMS (STACKS, TCB, ...) WILL
# CHANGE FROM BUILD TO BUILD. THIS IS BY DESIGN, THE PRIVATE DATA
# ITEMS ARE PRIVATE. Always use runtime accessor functions to obtain
# the information. Never expect to get handles to the private
# information at compile time.
#
#===============================================================================
# Module Scope Definitions
#===============================================================================

RCINIT_USES_FLAG = 'USES_RCINIT'
RCINIT_PRIORITY_ALIAS_MAP_FILE = 'rcinit_task_prio.csv' # Required, IMAGE OWNER delivered

RCINIT_STACK_STATIC = False                     # STACK STATIC ALLOCATION (BSS Section)
RCINIT_TCB_STATIC = True                        # TCB STATIC ALLOCATION (BSS Section)
RCINIT_PRIORITY_ALIAS_FINDCONFIG = False        # USE env.FindConfigFiles()

RCINIT_DEPENDENCIES = 'dependencies'            # tech area supplied (optional)
RCINIT_SEQUENCE_GROUP = 'sequence_group'        # tech area supplied
RCINIT_POLICY_OPTIN = 'policy_optin'            # tech area supplied (optional)
RCINIT_POLICY_DEFAULT = ['default']

THREAD_NAME = 'thread_name'                     # tech area supplied
THREAD_ENTRY = 'thread_entry'                   # tech area supplied
THREAD_TCB = 'tcb_name'                         # tech area supplied (optional)
THREAD_STACK = 'stack_size_bytes'               # tech area supplied
THREAD_STACK_STATIC = 'stack_section'           # tech area supplied
THREAD_PRIORITY = 'priority_amss_order'         # tech area supplied
THREAD_PRIORITY_ALIAS = 'priority_amss_order_enum' # tech area supplied
THREAD_AFFINITY = 'cpu_affinity'                # tech area supplied (optional)

THREAD_API = 'thread_type'                      # tech area supplied
THREAD_API_POSIX = 'RCINIT_TASK_POSIX'
THREAD_API_REX = 'RCINIT_TASK_REXTASK'
THREAD_API_QURT = 'RCINIT_TASK_QURTTASK'
THREAD_API_DAL = 'RCINIT_TASK_DALTASK'
THREAD_API_FUNC = 'RCINIT_TASK_INITFN'
THREAD_API_POLICY = 'RCINIT_TASK_POLICYFN'
THREAD_API_TYPES = [THREAD_API_POSIX, THREAD_API_REX, THREAD_API_QURT, THREAD_API_DAL, THREAD_API_FUNC]

INIT_NAME = 'init_name'                         # tech area supplied
INIT_ENTRY = 'init_function'                    # tech area supplied

POLICY_NAME = 'policy_name'                     # image owner supplied
POLICY_ENTRY = 'policy_function'                # image owner supplied

RCINIT_INFO_NAME = 'name'                       # internal key
RCINIT_INFO_TYPE = 'type'                       # internal key
RCINIT_INFO_HASH = 'hash'                       # internal key
RCINIT_INFO_GROUP = 'group'                     # internal key
RCINIT_INFO_API = 'api'                         # internal key
RCINIT_INFO_ENTRY = 'entry'                     # internal key
RCINIT_INFO_DEPENDENCY = 'dependency'           # internal key
RCINIT_INFO_POLICY = 'policy'                   # internal key
RCINIT_INFO_FUNCTION = 'function'               # internal key
RCINIT_INFO_TASK = 'task'                       # internal key
RCINIT_INFO_PRIORITY = 'priority'               # internal key
RCINIT_INFO_PRIORITY_ALIAS = 'priority_alias'   # internal key
RCINIT_INFO_STACK = 'stack'                     # internal key
RCINIT_INFO_STACK_STATIC = 'section'            # internal key
RCINIT_INFO_AFFINITY = 'affinity'               # internal key
RCINIT_INFO_DEFINED = 'defined'                 # internal key

RCINIT_DEPENDENCIES_FILTER = 'dependencies_filter' # internal key
RCINIT_INTERNAL_ORDER = '_order'                # internal key

RCINIT_NULL = 'RCINIT_NULL'                     # internal key
RCINIT_STKSZ_ZERO = 'RCINIT_STKSZ_ZERO'         # internal key
RCINIT_PRIO_INITFN = 'RCINIT_PRIO_INITFN'       # internal key
RCINIT_AFFINITY_ALL = 'RCINIT_AFFINITY_ALL'     # internal key

RCINIT_PRIO_ALIAS_FILE = 'RCINIT_PRIO_ALIAS_FILE' # internal key
RCINIT_PRIO_ALIAS_DICT = 'RCINIT_PRIO_ALIAS_DICT' # internal key

#env_rcinit[]
RCINIT_INFO_LIST = 'RCINIT_INFO_COLLECTOR'      # internal key

#env_rcinit_pol[]
RCINIT_POLICY_DICT = 'RCINIT_POLICY_COLLECTOR'  # internal key
RCINIT_NOPOLICY_ORDERED_LIST = 'RCINIT_ORDERED_COLLECTOR' # internal key
RCINIT_POLICY_USE_LIST = 'RCINIT_POLICY_USAGE_COLLECTOR' # internal key

RCINIT_NAME_MAXLEN = 15                         # ALL PL, ALL NHLOS API
RCINIT_OUTPUT_NA = '-'
RCINIT_OUTPUT_LEN = '*'
RCINIT_OUTPUT_TRUE = 'Y'
RCINIT_OUTPUT_FALSE = 'N'

#dict that defines possible run levels
RCINIT_SEQUENCE_GROUP_KEYS = {                  # internal key mapping
    'RCINIT_GROUP_0' : '0',   '0' : '0',
    'RCINIT_GROUP_1' : '1',   '1' : '1',
    'RCINIT_GROUP_2' : '2',   '2' : '2',
    'RCINIT_GROUP_3' : '3',   '3' : '3',
    'RCINIT_GROUP_4' : '4',   '4' : '4',
    'RCINIT_GROUP_5' : '5',   '5' : '5',
    'RCINIT_GROUP_6' : '6',   '6' : '6',
    'RCINIT_GROUP_7' : '7',   '7' : '7',
}

RCINIT_SEQUENCE_GROUP_MAX = 8                   # internal value
RCINIT_STACK_OVERHEAD = 128                     # internal estimate size of first exception frame
RCINIT_STACK_ROUNDUP = 4096                     # internal estimate size roundup to target page size
RCINIT_STACK_SECTION = '.STACK'                 # internal value (Treat as BSS)
RCINIT_STACK_PREFIX = 'rcinit_stk_'             # internal value
RCINIT_STACK_SUFFIX = ''                        # internal value
RCINIT_TCB_SECTION = '.TASK'                    # internal value (Treat as BSS)
RCINIT_TCB_PREFIX = 'rcinit_tid_'               # internal value
RCINIT_TCB_SUFFIX = ''                          # internal value

RCINIT_EXT_CSV = '.csv'                         # internal key
RCINIT_EXT_LOG = '.txt'                         # internal key
RCINIT_EXT_PB = '.rcpb'                         # internal key
RCINIT_EXT_PL = '.rcpl'                         # internal key
RCINIT_EXT_TGT = '.c'                           # internal key
RCINIT_EXT_OBJ = '.o'                           # internal key
RCINIT_EXT_PBK = '.rcpb'                        # internal key

# Shared Construction Environment 'globals'
ENV_RCINIT = 'ENV_RCINIT'                       # internal key
ENV_RCINIT_POL = 'ENV_RCINIT_POL'               # internal key

#===============================================================================
# SCONS Hooks
#===============================================================================

# exists: determines if the compilers, assemblers, linkers, tools,
# etc.. are available and present. this controls the generation of a
# construction environment assosicated to env.

def exists(env):
   ''' SCONS Tool, Exists, Check Conditions to Install a Construction Environment '''
   tool_debug(env, 'exists()')

   # Problem in SCONS Configuration
   if env is None or not isinstance(env, Environment):
      raise

   return True

# generate: this generates a construction environment for use by
# scons; the environment is provided to use.

def generate(env):
   ''' SCONS Tool, Generate, Generate a Construction Environment '''
   tool_debug(env, 'generate()')

   # Problem in SCONS Configuration
   if env is None or not isinstance(env, Environment):
      raise

   # Hint for SCONS debug output supplied by this tool
   #tool_info(env, 'Additional diagnostics with command line flag additions "--debug=stacktrace --debuginfo=rcinit"')

   # This tool supplies a USES_ flag for clients to utilize in the
   # construction environment.
   env.AddUsesFlags(RCINIT_USES_FLAG)

   # This tool saves 'globals' build information into the construction
   # environment that is provided by client calls of exported
   # methods. Two symbols are setup to assist in keeping policy data
   # seperated from nominal data -- even though there is one
   # construction environment...

   env[ENV_RCINIT] = env         # use first env for construction env task/function dictionary
   env[ENV_RCINIT_POL] = env     # use first env for construction env policy utilization dictionary

   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # Initialization of the construction environment 'globals'
   # information.

   env_rcinit[RCINIT_INFO_LIST] = []
   env_rcinit_pol[RCINIT_POLICY_DICT] = {}
   env_rcinit_pol[RCINIT_POLICY_USE_LIST] = RCINIT_POLICY_DEFAULT
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST] = [[],[],[],[],[],[],[],[]]

   # Locate the *REQUIRED* priority alias file. It is to be supplied
   # by the IMAGE owner at IMAGE_ROOT. To preclude build failure, an
   # example database will be used as fallback. Note, IMAGE specific
   # changes are owned and provided at IMAGE_ROOT. Such changes are
   # not captured to the example database as a convenience to any
   # IMAGE.

   fileItemPrio = None
   env[RCINIT_PRIO_ALIAS_DICT] = {}

   # Pathing to Configuration Files by Tool

   if RCINIT_PRIORITY_ALIAS_FINDCONFIG == True:

      fileItemPrio = env.FindConfigFiles(RCINIT_PRIORITY_ALIAS_MAP_FILE)

      if fileItemPrio is not None and len(fileItemPrio) != 0:
         env[RCINIT_PRIO_ALIAS_FILE] = fileItemPrio[0]
         prioReader = csv.DictReader(open(env[RCINIT_PRIO_ALIAS_FILE], 'r'))
         for row in prioReader:
            env[RCINIT_PRIO_ALIAS_DICT][row['TASK_LEGACY_AMSS_PRI_ORDER']] = row['NONHLOS_PRIORITY']
         tool_info(env, 'Priority Alias Map present for the build object ' + env[RCINIT_PRIO_ALIAS_FILE])
      else:
         tool_warning(env, 'Priority Alias Map absent for the build object ' + RCINIT_PRIORITY_ALIAS_MAP_FILE)

   # Pathing to Configuration Files by 'Hard Coded' Location

   else:

      if fileItemPrio == None:
         if env.has_key('IMAGE_ROOT'):
            fileItemPrio = getFileLocation(env, env.get('IMAGE_ROOT'), RCINIT_PRIORITY_ALIAS_MAP_FILE)
            if fileItemPrio is not None:
               tool_info(env, 'Priority Alias Map present for the build object ' + RCINIT_PRIORITY_ALIAS_MAP_FILE)
               env[RCINIT_PRIO_ALIAS_FILE] = fileItemPrio
               prioReader = csv.DictReader(open(env[RCINIT_PRIO_ALIAS_FILE], 'r'))
               for row in prioReader:
                  env[RCINIT_PRIO_ALIAS_DICT][row['TASK_LEGACY_AMSS_PRI_ORDER']] = row['NONHLOS_PRIORITY']
            else:
               tool_warning(env, 'Priority Alias Map absent for the build object ' + RCINIT_PRIORITY_ALIAS_MAP_FILE)
         else:
            tool_error(env, 'IMAGE_ROOT not Available, target team correction needed')

   # Final step is to associate this tool to the construction
   # environment. This activates the RCInitBuilder() for use.

   action = env.GetBuilderAction(tool_action, action_source = None)
   scanner = env.Scanner(tool_target_scanner, 'rcinit_target_scanner')
   builder = env.Builder(action = action, target_scanner = scanner, emitter = tool_emitter)

   env.Append(BUILDERS = {'RcinitBuilder' : builder}) # internalized
   env.Append(BUILDERS = {'RCInitBuilder' : builder}) # internalized

   # Client exposed methods to the tool. These function as 'pseudo
   # builders' to collect client information, validate, and then save
   # to the 'globals' construction environment.

   env.AddMethod(tool_method_add_task, 'AddRCInitTask')
   env.AddMethod(tool_method_add_function, 'AddRCInitFunc')
   env.AddMethod(tool_method_add_policy, 'AddRCInitPolicy')

   env.AddMethod(tool_method_add_playlist, 'AddRCInitPlaylist')
   env.AddMethod(tool_method_add_playbook, 'AddRCInitPlaybook')

#===============================================================================

def tool_update_file_playbook(env, target, content):
   ''' Output TGT File '''
   tool_debug(env, 'tool_update_file_playbook('+target+')')
   with open(target, 'w') as output:
      output.write(env.CreateFileBanner(os.path.basename(str(target)), style='C'))
      output.write('\n')
      for line in content:
         output.write(line)

def tool_update_file_playbook_log(env, target, content):
   ''' Output LOG File '''
   tool_debug(env, 'tool_update_file_playbook_log('+target+')')
   with open(target, 'w') as output:
      for line in content:
         output.write(line)

def tool_update_file_playlist(env, target, content=None):
   ''' Output PL File '''
   tool_debug(env, 'tool_update_file_playlist('+target+')')
   sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   with open(target, 'w') as output:
      for entry in sorted_entry:
         output.write(str(entry) + '\n')

def tool_update_file_playlist_csv(env, target, content=None):
   ''' Output CSV File '''
   tool_debug(env, 'tool_update_file_playlist_csv('+target+')')
   sorted_entry = sorted(env[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   with open(target, 'w') as output:
      # CSV File Header Row, Controls Output Columns
      hd = OrderedDict([
         (RCINIT_INFO_NAME, None), (RCINIT_INFO_TYPE, None), (RCINIT_INFO_HASH, None),
         (RCINIT_INFO_GROUP, None), (RCINIT_INFO_API, None), (RCINIT_INFO_ENTRY, None),
         (RCINIT_INFO_POLICY, None), (RCINIT_INFO_DEPENDENCY, None), (RCINIT_INFO_AFFINITY, None),
         (RCINIT_INFO_STACK, None), (RCINIT_INFO_PRIORITY, None), (RCINIT_INFO_PRIORITY_ALIAS, None),
         (RCINIT_INFO_STACK_STATIC, None),
      ])
      dw = csv.DictWriter(output, delimiter=',', fieldnames=hd, extrasaction='ignore', quoting=csv.QUOTE_MINIMAL)
      dw.writeheader()
      for entry in sorted_entry:
         dw.writerow(entry)

#===============================================================================

# emitter: run while reading sconscripts; used to tweak the targets
# and sources of the build step (eg, library building might also
# create intermediates that need to be added to targets, or cleanup
# artifacts). there is no file system activity here, just the
# specification of dependency.

# Returns: tuple of 2 lists, [target], [source]

def tool_emitter(target, source, env):
   ''' SCONS Tool, Emitter, Sanitize Target/Source Dependency '''
   tool_debug(env, 'tool_emitter('+str(target[0])+')')

   # Pull apart target and source pathing information for utilization
   # by tool_emitter.

   target_full = env.RealPath(str(target[0]))
   target_path = os.path.split(target_full)[0]
   target_stem, target_ext = os.path.splitext(target_full)

   # Sanitize input source list to only account for those files
   # that are actually present. The tool treats the input source
   # as optional, not required.

   source = filter(lambda x: os.path.exists(env.RealPath(str(x))) and os.path.splitext(env.RealPath(str(x)))[1] == RCINIT_EXT_PL, source)

   # Required additional source dependency information.

   if env.has_key(RCINIT_PRIO_ALIAS_FILE):
      rcinit_prio = env[RCINIT_PRIO_ALIAS_FILE]
      source.append(rcinit_prio)

   # Anticipated target dependency information. The associated files
   # are created with the target as intended side effect. Note, each
   # of the targets appended will be fed to the target_scanner later.

   if target_ext == RCINIT_EXT_PL or target_ext == RCINIT_EXT_TGT:

      rcinit_dict = File(target_stem + RCINIT_EXT_PL)
      env.Clean(target, rcinit_dict)
      target.append(rcinit_dict)
      #env.Alias('install', env.InstallAs(env.RealPath('${IMAGE_ROOT}/${SHORT_BUILDPATH}/${TARGET_NAME}_rcinit'+RCINIT_EXT_PL), rcinit_dict))

   if target_ext == RCINIT_EXT_CSV or target_ext == RCINIT_EXT_TGT:

      rcinit_csv = File(target_stem + RCINIT_EXT_CSV)
      env.Clean(target, rcinit_csv)
      target.append(rcinit_csv)
      #env.Alias('install', env.InstallAs(env.RealPath('${IMAGE_ROOT}/${SHORT_BUILDPATH}/${TARGET_NAME}_rcinit'+RCINIT_EXT_CSV), rcinit_csv))

   if target_ext == RCINIT_EXT_LOG or target_ext == RCINIT_EXT_TGT:

      rcinit_log = File(target_stem + RCINIT_EXT_LOG)
      env.Clean(target, rcinit_log)
      target.append(rcinit_log)
      #env.Alias('install', env.InstallAs(env.RealPath('${IMAGE_ROOT}/${SHORT_BUILDPATH}/${TARGET_NAME}_rcinit'+RCINIT_EXT_LOG), rcinit_log))

   return target, source

#===============================================================================

#target_scanner: run when explicit dependcies are up-to-date and it
#is otherwise possible for the step to be executed to build the file.
#this may add implicity dependency that must exist before the step
#can run. (eg, rebuild libraries before a program is linked). here is
#where some files called out by tool_emitter will be created if they
#do not exist.

# realize that this routine is subject to concurrent execution, and
# must not make any changes to the construction environment. also, it
# should noted that concurrent calling for a single node potentially
# would overwrite a file being concurrently created by a different
# node.

def tool_target_scanner(node, env, path):
   ''' SCONS Tool, Target Scanner, ... '''
   tool_debug(env, 'tool_target_scanner('+str(node)+')')

   returnList = [node]

   # Ignore output creation on appropriate SCONS options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      tool_debug(env, 'TARGET CLEAN/NO_EXEC during tool scanner')
      return returnList

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   target_full = env.RealPath(str(node))
   target_path = os.path.split(target_full)[0]
   target_stem, target_ext = os.path.splitext(target_full)

   # dependency target supplied by emitter

   if target_ext == RCINIT_EXT_PL:
      tool_update_file_playlist(env_rcinit, target_full)

   if target_ext == RCINIT_EXT_CSV:
      tool_update_file_playlist_csv(env_rcinit, target_full)

   return returnList


#===============================================================================

# action: this is the portion of the tool that takes the source list
# and creates a target from it.

def tool_action(target, source, env):
   ''' SCONS Tool, Action Function, ... '''
   tool_debug(env, 'tool_action('+str(target[0])+')')

   # Ignore output creation on appropriate SCONS options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      tool_debug(env, 'TARGET CLEAN/NO_EXEC during tool action')
      return 0 # Indicate SUCCESS back

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   RCINIT_STACK_SIZE_DYNAMIC = 0
   RCINIT_STACK_SIZE_STATIC = 0
   RCINIT_STACK_SIZE_TOTAL = 0
   RCINIT_STACK_SIZE_LARGEST = 0
   RCINIT_STACK_SIZE_LARGEST_NAME = ''

   RCINIT_PRIORITY_MAXIMUM = 0
   RCINIT_PRIORITY_MAXIMUM_NAME = ''
   RCINIT_PRIORITY_MINIMUM = 255
   RCINIT_PRIORITY_MINIMUM_NAME = ''

   target_full = env.RealPath(str(target[0]))
   target_path = os.path.split(target_full)[0]
   target_stem, target_ext = os.path.splitext(target_full)

   # Loading of Playlist files to create the Playbook; tool_emitter has already
   # sanatized the list to those that exist.

   playlists = map(lambda x: str(x), source)
   for playlist in playlists:
      playlist_stem, playlist_ext = os.path.splitext(env.RealPath(playlist))
      if playlist_ext == RCINIT_EXT_PL and playlist_stem != target_stem:
         tool_debug(env, 'Loading Playlist ' + playlist)
         with open(playlist, 'r') as input:
            for line in input:
               entry = eval(line)
               if isinstance(entry, OrderedDict):
                  if entry.has_key(RCINIT_INFO_TYPE):
                     if entry[RCINIT_INFO_TYPE] == RCINIT_INFO_TASK:
                        tool_method_add_task(env, None, entry)
                     elif entry[RCINIT_INFO_TYPE] == RCINIT_INFO_FUNCTION:
                        tool_method_add_function(env, None, entry)
                     elif entry[RCINIT_INFO_TYPE] == RCINIT_INFO_POLICY:
                        tool_method_add_policy(env, None, entry)
                     else:
                        tool_error(env, 'Specified Playlist incorrect internal format, no matching type {:s}'.format(playlist))
                  else:
                     tool_error(env, 'Specified Playlist incorrect internal format, no type {:s}'.format(playlist))
               else:
                  tool_error(env, 'Specified Playlist incorrect internal format, no matching instance {:s}'.format(playlist))

   # Prepare the Playbook output
   PlaybookOutput = []

   PlaybookOutput.append('/*Dynamic Stacks are allocated at runtime. Static stacks can be manipulated at*/\n')
   PlaybookOutput.append('/*link time by use of the data section name. Link time stack address manipulation is*/\n')
   PlaybookOutput.append('/*outside of the RCINIT Framework domain; consult the tools linker manual for data*/\n')
   PlaybookOutput.append('/*section manipulation by scatter link files during link time. The section names*/\n')
   PlaybookOutput.append('/*based on tech area supplied information, or the default supplied section.*/\n')

   #generate header includes
   PlaybookOutput.append('\n')
   if env.GetUsesFlag('USES_DAL'):
      PlaybookOutput.append('#include "rcinit_dal.h"\n')
   if env.GetUsesFlag('USES_POSIX'):
      PlaybookOutput.append('#include "rcinit_posix.h"\n')
   if env.GetUsesFlag('USES_QURT'):
      PlaybookOutput.append('#include "rcinit_qurt.h"\n')
   if env.GetUsesFlag('USES_REX'):
      PlaybookOutput.append('#include "rcinit_rex.h"\n')
   PlaybookOutput.append('#include "rcinit_internal.h"\n')

   PlaybookOutput.append('\n')
   PlaybookOutput.append('/*build_id {:s}*/\n'.format(env.get('BUILD_ID')))

   PlaybookOutput.append('\n#if defined(__cplusplus)\nextern "C" {\n#endif\n')

   PlaybookOutput.append('\n/* ******************************** */\n')

   #loop through tasks that registered with rcinit
   rcinit_ents = sorted(env_rcinit[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in rcinit_ents:

      PlaybookOutput.append('''
/**
name       {:s}
type       {:s}
defined    {:s}
policy     {:s}
dependency {:s}
*/\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_TYPE], entry[RCINIT_INFO_DEFINED], entry[RCINIT_INFO_POLICY],
   entry[RCINIT_INFO_DEPENDENCY]))

      # API is Function/Policy
      if entry[RCINIT_INFO_API] == THREAD_API_FUNC or entry[RCINIT_INFO_API] == THREAD_API_POLICY:

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void {:s}(void);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
static const rcinit_info rcinit_ro_{0:s} = {{
/*name*/      "{0:s}",
/*hash*/      {1:s},
/*api*/       {2:s},
/*entry*/     (rcinit_entry_p){3:s},
/*priority*/  {4:s}, /*{5:s}*/
/*stack*/     {6:s},
/*affinity*/  {7:s},
/*handle*/    RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY]))

      # API is DAL Workloop
      elif entry[RCINIT_INFO_API] == THREAD_API_DAL:

         if int(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if RCINIT_STACK_STATIC == True or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX + '_' + randomstring(8)
            PlaybookOutput.append('''
rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(16), section("{2:s}"))) = {{0}};\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC].upper()))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD

         # Volatile Memory
         PlaybookOutput.append('''
static rcinit_handle rcinit_rw_{0:s} = {{
(rcinit_tid_p)RCINIT_NULL, {2:s}, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], '', STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ DALResult {:s}(unsigned long, void*);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
static const rcinit_info rcinit_ro_{0:s} = {{
/*name*/      "{0:s}",
/*hash*/      {1:s},
/*api*/       {2:s},
/*entry*/     (rcinit_entry_p){3:s},
/*priority*/  {4:s}, /*{5:s}*/
/*stack*/     {6:s},
/*affinity*/  {7:s},
/*handle*/    &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY]))

      # API is POSIX Pthread
      elif entry[THREAD_API] == THREAD_API_POSIX:

         if int(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if RCINIT_STACK_STATIC == True or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX + '_' + randomstring(8)
            PlaybookOutput.append('''
rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(16), section("{2:s}"))) = {{0}};\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC].upper()))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD

         # Volatile Memory
         PlaybookOutput.append('''
static rcinit_handle rcinit_rw_{0:s} = {{
(rcinit_tid_p)RCINIT_NULL, {2:s}, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], '', STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void* {:s}(void*);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
static const rcinit_info rcinit_ro_{0:s} = {{
/*name*/      "{0:s}",
/*hash*/      {1:s},
/*api*/       {2:s},
/*entry*/     (rcinit_entry_p){3:s},
/*priority*/  {4:s}, /*{5:s}*/
/*stack*/     {6:s},
/*affinity*/  {7:s},
/*handle*/    &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY]))

      # API is QURT Thread
      elif entry[THREAD_API] == THREAD_API_QURT:

         if int(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if RCINIT_STACK_STATIC == True or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX + '_' + randomstring(8)
            PlaybookOutput.append('''
rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(16), section("{2:s}"))) = {{0}};\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC].upper()))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD

         # Volatile Memory
         PlaybookOutput.append('''
static rcinit_handle rcinit_rw_{0:s} = {{
(rcinit_tid_p)RCINIT_NULL, {2:s}, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], '', STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void {:s}(void*);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
static const rcinit_info rcinit_ro_{0:s} = {{
/*name*/      "{0:s}",
/*hash*/      {1:s},
/*api*/       {2:s},
/*entry*/     (rcinit_entry_p){3:s},
/*priority*/  {4:s}, /*{5:s}*/
/*stack*/     {6:s},
/*affinity*/  {7:s},
/*handle*/    &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY]))

      # API is REX Task
      elif entry[THREAD_API] == THREAD_API_REX:

         if int(entry[RCINIT_INFO_STACK]) > RCINIT_STACK_SIZE_LARGEST:
            RCINIT_STACK_SIZE_LARGEST = int(entry[RCINIT_INFO_STACK])
            RCINIT_STACK_SIZE_LARGEST_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) < RCINIT_PRIORITY_MINIMUM:
            RCINIT_PRIORITY_MINIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MINIMUM_NAME = entry[RCINIT_INFO_NAME]

         if int(entry[RCINIT_INFO_PRIORITY]) > RCINIT_PRIORITY_MAXIMUM:
            RCINIT_PRIORITY_MAXIMUM = int(entry[RCINIT_INFO_PRIORITY])
            RCINIT_PRIORITY_MAXIMUM_NAME = entry[RCINIT_INFO_NAME]

         # Static Stack
         RCINIT_STACK_SIZE_TOTAL = RCINIT_STACK_SIZE_TOTAL + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
         STACK_NAME = 'RCINIT_NULL'
         if RCINIT_STACK_STATIC == True or entry[RCINIT_INFO_STACK_STATIC] != None:
            if entry[RCINIT_INFO_STACK_STATIC] == None:
               entry[RCINIT_INFO_STACK_STATIC] = RCINIT_STACK_SECTION
            RCINIT_STACK_SIZE_STATIC = RCINIT_STACK_SIZE_STATIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD
            STACK_NAME = RCINIT_STACK_PREFIX + entry[RCINIT_INFO_NAME] + RCINIT_STACK_SUFFIX + '_' + randomstring(8)
            PlaybookOutput.append('''
rcinit_stack_t {0:s}[({1:s}+sizeof(_rcxh_scope_t))/sizeof(rcinit_stack_t)] __attribute__((aligned(16), section("{2:s}"))) = {{0}};\n'''.format(STACK_NAME, entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_STACK_STATIC].upper()))
         else:
            RCINIT_STACK_SIZE_DYNAMIC = RCINIT_STACK_SIZE_DYNAMIC + int(entry[RCINIT_INFO_STACK]) + RCINIT_STACK_OVERHEAD

         if entry[THREAD_TCB] == RCINIT_NULL:
            # Volatile Memory
            PlaybookOutput.append('''
//rex_tcb_type {3:s}{1:s}{4:s}{5:s} = {{0}}; /* PRIVATE */
rex_tcb_type {1:s}_tcb = {{0}}; // IMPLICIT NOT PRIVATE HACK

static rcinit_handle rcinit_rw_{0:s} = {{
//(rcinit_tid_p)&{3:s}{1:s}{4:s}{5:s}, {2:s}, RCINIT_NULL, RCINIT_NULL
(rcinit_tid_p)&{1:s}_tcb, {2:s}, RCINIT_NULL, RCINIT_NULL // IMPLICIT NOT PRIVATE HACK
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_NAME], STACK_NAME, RCINIT_TCB_PREFIX, RCINIT_TCB_SUFFIX, '_' + randomstring(8)))
         else:
            # TCB Special Case
            PlaybookOutput.append('''
rex_tcb_type {1:s} = {{0}}; /* EXPLICIT NOT PRIVATE */

static rcinit_handle rcinit_rw_{0:s} = {{
(rcinit_tid_p)&{1:s}, {2:s}, RCINIT_NULL, RCINIT_NULL
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[THREAD_TCB], STACK_NAME))

         # Non NULL Entry
         if entry[RCINIT_INFO_ENTRY] != RCINIT_NULL:
            PlaybookOutput.append('''
/*signature*/ void {:s}(unsigned long);\n'''.format(entry[RCINIT_INFO_ENTRY]))

         # Const Memory
         PlaybookOutput.append('''
static const rcinit_info rcinit_ro_{0:s} = {{
/*name*/      "{0:s}",
/*hash*/      {1:s},
/*api*/       {2:s},
/*entry*/     (rcinit_entry_p){3:s},
/*priority*/  {4:s}, /*{5:s}*/
/*stack*/     {6:s},
/*affinity*/  {7:s},
/*handle*/    &rcinit_rw_{0:s}
}};\n'''.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_HASH], entry[RCINIT_INFO_API], entry[RCINIT_INFO_ENTRY],
   entry[RCINIT_INFO_PRIORITY], entry[RCINIT_INFO_PRIORITY_ALIAS], entry[RCINIT_INFO_STACK], entry[RCINIT_INFO_AFFINITY]))

   #done generating rcinit structs

   PlaybookOutput.append('\n/* ******************************** */\n')

   #generate task map
   PlaybookOutput.append('\n')
   rcinitNames = []
   for entry in env_rcinit[RCINIT_INFO_LIST]:
      rcinitNames.append(entry[RCINIT_INFO_NAME])
   rcinitNames.sort()
   PlaybookOutput.append('const rcinit_internal_name_map_t rcinit_internal_name_map[] = {\n')
   for key in rcinitNames: PlaybookOutput.append(' {{ "{0:s}", &rcinit_ro_{0:s} }},\n'.format(key))
   PlaybookOutput.append(' { RCINIT_NULL, RCINIT_NULL }\n};\n')
   PlaybookOutput.append('const int rcinit_internal_name_map_size = sizeof(rcinit_internal_name_map) / sizeof(rcinit_internal_name_map_t);\n')

   PlaybookOutput.append('\n/* ******************************** */\n')

   #sort group levels given dependencies
   grpNum = 0
   for grpLvl in env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST]:
      #first generate a list of names at the group level
      taskNames = [ dict_[THREAD_NAME] for dict_ in grpLvl if dict_.has_key(THREAD_NAME)]
      initNames = [ dict_[INIT_NAME] for dict_ in grpLvl if dict_.has_key(INIT_NAME)]
      #only init functions allowed as dependencies
      grpNames = set(initNames)

      #form dictionary of vertices for topological sort
      grpDict = {}
      for item in grpLvl:
         filteredDependencies = list(set(item[RCINIT_DEPENDENCIES]) & grpNames)
         item[RCINIT_DEPENDENCIES_FILTER] = filteredDependencies
         grpDict[item[RCINIT_INFO_NAME]] = filteredDependencies

      #sort based on dependencies
      grpSorted = topological_sort(grpDict)
      grpSorted.reverse()

      #check if there was a cycle
      if len(grpSorted) != len(set(initNames) | set(taskNames)):
         tool_error(env, 'Cycle in dependencies found')

      #append an ordering to each dictionary
      for item in grpLvl:
         if item.has_key(THREAD_NAME):
            item[RCINIT_INTERNAL_ORDER] = grpSorted.index(item[THREAD_NAME])
         else:
            #exception for policy functions
            #ignore if internal ordering is already defined
            if not item.has_key(RCINIT_INTERNAL_ORDER):
               item[RCINIT_INTERNAL_ORDER] = grpSorted.index(item[INIT_NAME])

      #sort the dictionaries
      env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][grpNum] = sorted(grpLvl, key=itemgetter(RCINIT_INTERNAL_ORDER))
      grpNum += 1

   #sort the nonpolicy ordered list as well for output
   for policy in env_rcinit_pol[RCINIT_POLICY_DICT]:
      grpNum = 0
      for grpLvl in env_rcinit_pol[RCINIT_POLICY_DICT][policy]:
         env_rcinit_pol[RCINIT_POLICY_DICT][policy][grpNum] = sorted(grpLvl, key=itemgetter(RCINIT_INTERNAL_ORDER))
         grpNum += 1

   #generate rcinit arrays
   for policy in env_rcinit_pol[RCINIT_POLICY_DICT]:
      #skip if policy is not used in this build
      if policy not in env_rcinit_pol[RCINIT_POLICY_USE_LIST]:
         continue
      PlaybookOutput.append('\n')
      for i in range(RCINIT_SEQUENCE_GROUP_MAX):
         PlaybookOutput.append('static const rcinit_info_t* rcinit_{:s}_{:d}[] = {{\n'.format(policy, i))
         for rcinitInfo in env_rcinit_pol[RCINIT_POLICY_DICT][policy][i]:
            PlaybookOutput.append('&rcinit_ro_{:s},\n'.format(rcinitInfo[RCINIT_INFO_NAME]))
         PlaybookOutput.append('RCINIT_NULL\n}};\n\n'.format(0))

      PlaybookOutput.append('static const rcinit_info_t** rcinit_group_{:s}[] = {{\n'.format(policy))
      for i in range(RCINIT_SEQUENCE_GROUP_MAX):
         PlaybookOutput.append('rcinit_{:s}_{:d},\n'.format(policy, i))
      PlaybookOutput.append('RCINIT_NULL\n}};\n'.format(0))
   #done generating rcinit arrays

   PlaybookOutput.append('\n/* ******************************** */\n')

   #generate policy arrays for in use policies
   policyList = list(set(env_rcinit_pol[RCINIT_POLICY_DICT].keys()) & set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]))
   policyList.sort()
   PlaybookOutput.append('\n')
   PlaybookOutput.append('const rcinit_internal_policy_map_t rcinit_internal_policy_map[] = {{\n'.format(0))
   for policy  in policyList:
      PlaybookOutput.append(' {{ "{:s}", {:d} }},\n'.format(policy, policyList.index(policy)))
   PlaybookOutput.append(' {RCINIT_NULL, RCINIT_ZERO}\n')
   PlaybookOutput.append('}};\n'.format(0))
   PlaybookOutput.append('const int rcinit_internal_policy_map_size = sizeof(rcinit_internal_policy_map) / sizeof(rcinit_internal_policy_map_t);\n')

   PlaybookOutput.append('\n')
   PlaybookOutput.append('const rcinit_info_t*** rcinit_internal_groups[] = {{\n'.format(0))
   for policy in policyList:
      PlaybookOutput.append(' rcinit_group_{:s},\n'.format(policy))
   PlaybookOutput.append(' RCINIT_NULL\n')
   PlaybookOutput.append('}};\n'.format(0))

   PlaybookOutput.append('const RCINIT_NAME rcinit_internal_policy_list[] = {{\n'.format(0))
   for policy  in policyList:
      PlaybookOutput.append(' "{:s}",\n'.format(policy))
   PlaybookOutput.append(' RCINIT_NULL\n')
   PlaybookOutput.append('}};\n'.format(0))

   PlaybookOutput.append('\n/* ******************************** */\n')

   PlaybookOutput.append('\n#if defined(__cplusplus)\n}\n#endif\n\n')

   #form output log
   PlaybookOutputLog = []
   PlaybookOutputLog.append('****************************************\n')
   PlaybookOutputLog.append('RCINIT OUTPUT LOG\n')

   if env.has_key(RCINIT_PRIO_ALIAS_FILE):
      PlaybookOutputLog.append('\n')
      output_text = '..../'+env[RCINIT_PRIO_ALIAS_FILE].replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
      PlaybookOutputLog.append('NHLOS Priority Alias Map {:s}\n'.format(output_text))

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('NHLOS Configured API ')
   if env.GetUsesFlag('USES_DAL') is True:
      PlaybookOutputLog.append('USES_DAL ')
   if env.GetUsesFlag('USES_POSIX') is True:
      PlaybookOutputLog.append('USES_POSIX ')
   if env.GetUsesFlag('USES_QURT') is True:
      PlaybookOutputLog.append('USES_QURT ')
   if env.GetUsesFlag('USES_REX') is True:
      PlaybookOutputLog.append('USES_REX ')
   PlaybookOutputLog.append('\n')

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('Build Stack Allocation ESTIMATES {:s} Total, {:s} Dynamic, {:s} Static\n'.format(
      str(roundup(RCINIT_STACK_SIZE_TOTAL, RCINIT_STACK_ROUNDUP)),
      str(roundup(RCINIT_STACK_SIZE_DYNAMIC, RCINIT_STACK_ROUNDUP)),
      str(roundup(RCINIT_STACK_SIZE_STATIC, RCINIT_STACK_ROUNDUP))))

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('Build Maximum Stack         {: <12s} {: <30s}\n'.format(str(RCINIT_STACK_SIZE_LARGEST), RCINIT_STACK_SIZE_LARGEST_NAME))
   PlaybookOutputLog.append('Build Minimum Priority      {: <12s} {: <30s}\n'.format(str(RCINIT_PRIORITY_MINIMUM), RCINIT_PRIORITY_MINIMUM_NAME))
   PlaybookOutputLog.append('Build Maximum Priority      {: <12s} {: <30s}\n'.format(str(RCINIT_PRIORITY_MAXIMUM), RCINIT_PRIORITY_MAXIMUM_NAME))

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('Specific field does not appy is denoted by "' + RCINIT_OUTPUT_NA + '"\n')
   PlaybookOutputLog.append('Tech Area supplied Name too long to be unique with NHLOS is denoted by "' + RCINIT_OUTPUT_LEN + '"\n')

   PlaybookOutputLog.append('\n')
   PlaybookOutputLog.append('****************************************\n')

   PlaybookOutputLog.append('\n')
   debuglinefmt = '{: <30s} {: <25s} {: <40s} {: <12s} {: <12s} {: <60s} {: <40s}\n'

   for i in range(RCINIT_SEQUENCE_GROUP_MAX):

      PlaybookOutputLog.append('*** GROUP {:d}\n'.format(i))
      PlaybookOutputLog.append(debuglinefmt.format('Name', 'NHLOS API', 'NHLOS Priority', 'Stack', 'StackDyn', 'Dependency', 'Policy'))
      PlaybookOutputLog.append('\n')

      for entry in env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][i]:
         #skip entry if policy doesnt apply
         filteredPolicyList = list(set(entry[RCINIT_POLICY_OPTIN]) & set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]))
         if len(filteredPolicyList) == 0:
            continue
         if entry[RCINIT_INFO_TYPE] == RCINIT_INFO_FUNCTION or entry[RCINIT_INFO_TYPE] == RCINIT_INFO_POLICY:
            PlaybookOutputLog.append(debuglinefmt.format(
               RCINIT_OUTPUT_LEN + entry[RCINIT_INFO_NAME] if len(entry[RCINIT_INFO_NAME]) > RCINIT_NAME_MAXLEN else entry[RCINIT_INFO_NAME],
               RCINIT_OUTPUT_NA, RCINIT_OUTPUT_NA, RCINIT_OUTPUT_NA, RCINIT_OUTPUT_NA, entry[RCINIT_DEPENDENCIES_FILTER], filteredPolicyList))
      for entry in env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][i]:
         #skip entry if policy doesnt apply
         filteredPolicyList = list(set(entry[RCINIT_POLICY_OPTIN]) & set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]))
         if len(filteredPolicyList) == 0:
            continue
         if entry[RCINIT_INFO_TYPE] == RCINIT_INFO_TASK:
            if entry[THREAD_PRIORITY_ALIAS] is not None:
               debugPrioEnum = entry[THREAD_PRIORITY_ALIAS] + '(' + entry[THREAD_PRIORITY] + ')'
            else:
               debugPrioEnum = entry[THREAD_PRIORITY]
            PlaybookOutputLog.append(debuglinefmt.format(
               RCINIT_OUTPUT_LEN + entry[RCINIT_INFO_NAME] if len(entry[RCINIT_INFO_NAME]) > RCINIT_NAME_MAXLEN else entry[RCINIT_INFO_NAME],
               entry[THREAD_API], debugPrioEnum, entry[THREAD_STACK],
               RCINIT_OUTPUT_TRUE if entry[RCINIT_INFO_STACK_STATIC] == None else RCINIT_OUTPUT_FALSE,
               RCINIT_OUTPUT_NA, filteredPolicyList))

      PlaybookOutputLog.append('\n-----------------------------------------------------------------------------------\n')

   PlaybookOutputLog.append('\n')
   debuglinefmt = '{: <30s} {: <60s}\n'
   PlaybookOutputLog.append(debuglinefmt.format('Name', 'Defined At'))
   rcinit_ents = sorted(env_rcinit[RCINIT_INFO_LIST], key=lambda k: k[RCINIT_INFO_NAME])
   for entry in rcinit_ents:
      PlaybookOutputLog.append(debuglinefmt.format(entry[RCINIT_INFO_NAME], entry[RCINIT_INFO_DEFINED]))

   #append output log to end of file
   PlaybookOutput.append('/*\n')
   for line in PlaybookOutputLog:
      PlaybookOutput.append(line)
   PlaybookOutput.append('*/\n')

   # Output what was requested from builder based on extension

   if target_ext == RCINIT_EXT_TGT:
      tool_update_file_playbook(env_rcinit, target_full, PlaybookOutput)

   # Intermediate Output
   if target_ext == RCINIT_EXT_PL:
      tool_update_file_playlist(env_rcinit, target_full)

   # Intermediate Output
   if target_ext == RCINIT_EXT_CSV:
      tool_update_file_playlist_csv(env_rcinit, target_full)

   # Diagnostic Output
   if target_ext == RCINIT_EXT_LOG:
      tool_update_file_playbook_log(env_rcinit, target_full, PlaybookOutputLog)

   return 0 # Indicate SUCCESS back

#===============================================================================

def tool_method_add_playlist(env, build_ids, output):
   ''' Method Call, Calls RCInitBuilder '''
   tool_debug(env, 'tool_method_add_playlist('+str(output[0])+')')

   if not isinstance(output, list):
      output = [output]

   output_full = env.RealPath(str(output[0]))
   output_path = os.path.split(output_full)[0]
   output_stem, output_ext = os.path.splitext(output_full)

   if output_ext == '':
      output_full = output_stem + RCINIT_EXT_PL
      env.RCInitBuilder(target=output_full, source=None)

   elif output_ext == RCINIT_EXT_PL:
      env.RCInitBuilder(target=output_full, source=None)

   elif output_ext == RCINIT_EXT_CSV:
      env.RCInitBuilder(target=output_full, source=None)

   else:
      tool_error(env, 'Method call with unrecognised file type "' + output_ext + '"')

   return output, input

#===============================================================================

def tool_method_add_playbook(env, build_ids, output, input):
   ''' Method Call, Calls RCInitBuilder '''
   tool_debug(env, 'tool_method_add_playbook('+str(output[0])+')')

   if not isinstance(input, list):
      input = [input]

   if not isinstance(output, list):
      output = [output]

   output_full = env.RealPath(str(output[0]))
   output_path = os.path.split(output_full)[0]
   output_stem, output_ext = os.path.splitext(output_full)

   if output_ext == '':
      output_full = output_stem + RCINIT_EXT_TGT
      env.RCInitBuilder(target=output_full, source=input)

   elif output_ext == RCINIT_EXT_PL:
      env.RCInitBuilder(target=output_full, source=input)

   elif output_ext == RCINIT_EXT_TGT:
      env.RCInitBuilder(target=output_full, source=input)

   elif output_ext == RCINIT_EXT_LOG:
      env.RCInitBuilder(target=output_full, source=input)

   else:
      tool_error(env, 'Method call with unrecognised file type "' + output_ext + '"')

   return output, input

#===============================================================================

def tool_method_add_task(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Task
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # caller python frame of interest
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   output_dict = OrderedDict()
   output_dict[RCINIT_INFO_NAME] = None
   output_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_TASK
   output_dict[RCINIT_INFO_HASH] = None
   output_dict[RCINIT_INFO_GROUP] = None
   output_dict[RCINIT_INFO_API] = None
   output_dict[RCINIT_INFO_ENTRY] = None
   output_dict[RCINIT_INFO_POLICY] = None
   output_dict[RCINIT_INFO_DEPENDENCY] = None
   output_dict[RCINIT_INFO_AFFINITY] = None
   output_dict[RCINIT_INFO_STACK] = None
   output_dict[RCINIT_INFO_STACK_STATIC] = None
   output_dict[RCINIT_INFO_PRIORITY] = None
   output_text = '..../'+filename.replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
   output_dict[RCINIT_INFO_DEFINED] = { 'file': output_text, 'line': line_number }

   #read in name
   if not input_dict.has_key(THREAD_NAME):
      tool_error(env, THREAD_NAME + ' required')
   if len(input_dict[THREAD_NAME]) > RCINIT_NAME_MAXLEN:
      tool_warning(env, THREAD_NAME + ' name exceeds signifigant length shorten to ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[THREAD_NAME])

   #ensure name is unique
   output_dict[THREAD_NAME] = input_dict[THREAD_NAME].lower()
   output_dict[RCINIT_INFO_NAME] = output_dict[THREAD_NAME]
   output_dict[RCINIT_INFO_HASH] = '{:#x}'.format(namehash(output_dict[RCINIT_INFO_NAME]))

   # Process input on SCONS Command Options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      tool_debug(env, 'TARGET CLEAN/NO_EXEC RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED
   # Process input on specified BUILD_ID list is None
   ##elif build_ids is None: # WILL BE NONE FROM RCPL
   ##   tool_debug(env, 'TARGET NOT SPECIFIED RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
   ##   return None # RETURN, IGNORED
   # Ignore input on specified BUILD_ID not being active
   elif build_ids is not None and not env.IsTargetEnable(build_ids):
      tool_debug(env, 'TARGET NOT ACTIVE RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED

   for threads in env_rcinit[RCINIT_INFO_LIST]:
      if threads.has_key(RCINIT_INFO_NAME) and output_dict[RCINIT_INFO_NAME] == threads[RCINIT_INFO_NAME]:
         tool_error(env, 'Duplicate name {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      if threads.has_key(RCINIT_INFO_HASH) and output_dict[RCINIT_INFO_HASH] == threads[RCINIT_INFO_HASH]:
         tool_error(env, 'Duplicate name hash {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in policy list
   if input_dict.has_key(RCINIT_POLICY_OPTIN):
      if not isinstance(input_dict[RCINIT_POLICY_OPTIN], list):
         tool_error(env, 'Requires valid policy list {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_POLICY_OPTIN] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
      output_dict[RCINIT_INFO_POLICY] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
   else:
      output_dict[RCINIT_POLICY_OPTIN] = RCINIT_POLICY_DEFAULT
      output_dict[RCINIT_INFO_POLICY] = RCINIT_POLICY_DEFAULT

   #read in sequence level
   if not input_dict.has_key(RCINIT_SEQUENCE_GROUP):
      tool_error(env, 'Requires group {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   if input_dict[RCINIT_SEQUENCE_GROUP] not in RCINIT_SEQUENCE_GROUP_KEYS.keys():
      tool_error(env, 'Requires valid group {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   output_dict[RCINIT_SEQUENCE_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]
   output_dict[RCINIT_INFO_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]

   #read in thread type
   if input_dict.has_key(THREAD_API):
      if input_dict[THREAD_API] not in THREAD_API_TYPES:
         tool_error(env, 'Requires valid NHLOS KERNEL API {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[THREAD_API] = input_dict[THREAD_API]
      output_dict[RCINIT_INFO_API] = input_dict[THREAD_API]
   else:
      output_dict[THREAD_API] = THREAD_API_REX
      output_dict[RCINIT_INFO_API] = THREAD_API_REX

   #validation
   error = 0
   if output_dict[RCINIT_INFO_API] == THREAD_API_DAL and not env.GetUsesFlag('USES_DAL'):
      error = 1
   elif output_dict[RCINIT_INFO_API] == THREAD_API_POSIX and not env.GetUsesFlag('USES_POSIX'):
      error = 1
   elif output_dict[RCINIT_INFO_API] == THREAD_API_QURT and not env.GetUsesFlag('USES_QURT'):
      error = 1
   elif output_dict[RCINIT_INFO_API] == THREAD_API_REX and not env.GetUsesFlag('USES_REX'):
      error = 1
   if error == 1:
      tool_error(env, 'Build does not support specific NHLOS KERNEL API {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   if input_dict.has_key(THREAD_STACK):
      output_dict[THREAD_STACK] = input_dict[THREAD_STACK]
      output_dict[RCINIT_INFO_STACK] = input_dict[THREAD_STACK]
   else:
      output_dict[THREAD_STACK] = ''
      output_dict[RCINIT_INFO_STACK] = ''

   if input_dict.has_key(THREAD_STACK_STATIC):
      output_dict[THREAD_STACK_STATIC] = input_dict[THREAD_STACK_STATIC]
      output_dict[RCINIT_INFO_STACK_STATIC] = input_dict[THREAD_STACK_STATIC]

   #read in priority
   output_dict[THREAD_PRIORITY_ALIAS] = None

   if input_dict.has_key(THREAD_PRIORITY):
      #check to see if this priority is mappable from prio csv
      if input_dict[THREAD_PRIORITY] in env[RCINIT_PRIO_ALIAS_DICT].keys():
         output_dict[THREAD_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[THREAD_PRIORITY]]
         output_dict[THREAD_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]
         output_dict[RCINIT_INFO_PRIORITY] = env[RCINIT_PRIO_ALIAS_DICT][input_dict[THREAD_PRIORITY]]
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]
      else:
         output_dict[THREAD_PRIORITY] = input_dict[THREAD_PRIORITY]
         output_dict[THREAD_PRIORITY_ALIAS] = None
         output_dict[RCINIT_INFO_PRIORITY] = input_dict[THREAD_PRIORITY]
         output_dict[RCINIT_INFO_PRIORITY_ALIAS] = input_dict[THREAD_PRIORITY]
   else:
      output_dict[THREAD_PRIORITY] = ''
      output_dict[RCINIT_INFO_PRIORITY] = ''
      output_dict[RCINIT_INFO_PRIORITY_ALIAS] = ''

   #read in thread entry
   if input_dict.has_key(THREAD_ENTRY):
      output_dict[THREAD_ENTRY] = input_dict[THREAD_ENTRY]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[THREAD_ENTRY]
   else:
      output_dict[THREAD_ENTRY] = output_dict[THREAD_NAME] + '_task'
      output_dict[RCINIT_INFO_ENTRY] = output_dict[THREAD_ENTRY]
      tool_warning(env, THREAD_ENTRY + ' should be tech area supplied, not use a default ' + input_dict[THREAD_NAME])

	#read in thread tcb
   if input_dict.has_key(THREAD_TCB):
      output_dict[THREAD_TCB] = input_dict[THREAD_TCB]
      tool_warning(env, THREAD_TCB + ' should not be tech area supplied, definition not private ' + input_dict[THREAD_NAME])
   else:
      output_dict[THREAD_TCB] = RCINIT_NULL

   #read in dependencies (not allowed for tasks)
   output_dict[RCINIT_DEPENDENCIES] = []
   output_dict[RCINIT_INFO_DEPENDENCY] = []

   #read in cpu affinity
   if input_dict.has_key(THREAD_AFFINITY):
      output_dict[THREAD_AFFINITY] = input_dict[THREAD_AFFINITY]
      output_dict[RCINIT_INFO_AFFINITY] = input_dict[THREAD_AFFINITY]
   else:
      output_dict[THREAD_AFFINITY] = RCINIT_AFFINITY_ALL
      output_dict[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL

   #if this is a new policy, create dictionary/lists
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      if policy not in env_rcinit_pol[RCINIT_POLICY_DICT].keys():
         env_rcinit_pol[RCINIT_POLICY_DICT][policy] = []
         for i in range(RCINIT_SEQUENCE_GROUP_MAX):
            env_rcinit_pol[RCINIT_POLICY_DICT][policy].append([])
   #add entry to each policy  list
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][int(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      env_rcinit_pol[RCINIT_POLICY_DICT][policy][int(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)

   #add to environment descriptor
   env_rcinit[RCINIT_INFO_LIST].append(output_dict)
   tool_debug(env, 'RCInitAddTask {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))

   return None

#===============================================================================

def tool_method_add_function(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Function
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # caller python frame of interest
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   output_dict = OrderedDict()
   output_dict[RCINIT_INFO_NAME] = None
   output_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_FUNCTION
   output_dict[RCINIT_INFO_HASH] = None
   output_dict[RCINIT_INFO_GROUP] = None
   output_dict[RCINIT_INFO_API] = None
   output_dict[RCINIT_INFO_ENTRY] = None
   output_dict[RCINIT_INFO_POLICY] = None
   output_dict[RCINIT_INFO_DEPENDENCY] = None
   output_dict[RCINIT_INFO_AFFINITY] = None
   output_dict[RCINIT_INFO_STACK] = None
   output_dict[RCINIT_INFO_PRIORITY] = None
   output_text = '..../'+filename.replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
   output_dict[RCINIT_INFO_DEFINED] = { 'file': output_text, 'line': line_number }

   #read in name
   if not input_dict.has_key(INIT_NAME):
      tool_error(env, INIT_NAME + ' required')
   if len(input_dict[INIT_NAME]) > RCINIT_NAME_MAXLEN:
      tool_warning(env, INIT_NAME + ' name exceeds signifigant length shorten to ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[INIT_NAME])

   #ensure name is unique
   output_dict[INIT_NAME] = input_dict[INIT_NAME].lower()
   output_dict[RCINIT_INFO_NAME] = output_dict[INIT_NAME]
   output_dict[RCINIT_INFO_HASH] = '{:#x}'.format(namehash(output_dict[RCINIT_INFO_NAME]))

   # Process input on SCONS Command Options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      tool_debug(env, 'TARGET CLEAN/NO_EXEC RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED
   # Process input on specified BUILD_ID list is None
   ##elif build_ids is None: # WILL BE NONE
   ##   tool_debug(env, 'TARGET NOT SPECIFIED RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
   ##   return None # RETURN, IGNORED
   # Ignore input on specified BUILD_ID not being active
   elif build_ids is not None and not env.IsTargetEnable(build_ids):
      tool_debug(env, 'TARGET NOT ACTIVE RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED

   for threads in env_rcinit[RCINIT_INFO_LIST]:
      if threads.has_key(RCINIT_INFO_NAME) and output_dict[RCINIT_INFO_NAME] == threads[RCINIT_INFO_NAME]:
         tool_error(env, 'Duplicate name {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      if threads.has_key(RCINIT_INFO_HASH) and output_dict[RCINIT_INFO_HASH] == threads[RCINIT_INFO_HASH]:
         tool_error(env, 'Duplicate name hash {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in policy list
   if input_dict.has_key(RCINIT_POLICY_OPTIN):
      if not isinstance(input_dict[RCINIT_POLICY_OPTIN], list):
         tool_error(env, 'Requires valid policy list {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_POLICY_OPTIN] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
      output_dict[RCINIT_INFO_POLICY] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
   else:
      output_dict[RCINIT_POLICY_OPTIN] = RCINIT_POLICY_DEFAULT
      output_dict[RCINIT_INFO_POLICY] = RCINIT_POLICY_DEFAULT

   #read in init function if applicable
   if input_dict.has_key(INIT_ENTRY):
      output_dict[INIT_ENTRY] = input_dict[INIT_ENTRY]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
   else:
      output_dict[INIT_ENTRY] = output_dict[INIT_NAME] + '_init'
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
      tool_warning(env, INIT_NAME + ' should be tech area supplied, not use a default ' + input_dict[INIT_ENTRY])

   #read in sequence level
   if not input_dict.has_key(RCINIT_SEQUENCE_GROUP):
      tool_error(env, 'Requires group {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   if input_dict[RCINIT_SEQUENCE_GROUP] not in RCINIT_SEQUENCE_GROUP_KEYS.keys():
      tool_error(env, 'Requires valid group {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   output_dict[RCINIT_SEQUENCE_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]
   output_dict[RCINIT_INFO_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]

   #init function, no thread type
   output_dict[THREAD_API] = THREAD_API_FUNC
   output_dict[RCINIT_INFO_API] = THREAD_API_FUNC

   #read in stack size
   output_dict[THREAD_STACK] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_STACK] = RCINIT_STKSZ_ZERO

   #read in priority
   output_dict[THREAD_PRIORITY] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_PRIORITY] = RCINIT_PRIO_INITFN
   output_dict[RCINIT_INFO_PRIORITY_ALIAS] = ''

   #read in cpu affinity
   output_dict[THREAD_AFFINITY] = RCINIT_AFFINITY_ALL
   output_dict[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL

   #read in dependencies
   if input_dict.has_key(RCINIT_DEPENDENCIES):
      if not isinstance(input_dict[RCINIT_DEPENDENCIES], list):
         tool_error(env, 'Requires valid dependency list {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_DEPENDENCIES] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
      output_dict[RCINIT_INFO_DEPENDENCY] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
   else:
        output_dict[RCINIT_DEPENDENCIES] = []
        output_dict[RCINIT_INFO_DEPENDENCY] = []

   #if this is a new policy, create dictionary/lists
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      if policy not in env_rcinit_pol[RCINIT_POLICY_DICT].keys():
         env_rcinit_pol[RCINIT_POLICY_DICT][policy] = []
         for i in range(RCINIT_SEQUENCE_GROUP_MAX):
            env_rcinit_pol[RCINIT_POLICY_DICT][policy].append([])
   #add entry to each policy  list
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][int(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      env_rcinit_pol[RCINIT_POLICY_DICT][policy][int(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)

   #add to environment descriptor
   env_rcinit[RCINIT_INFO_LIST].append(output_dict)
   tool_debug(env, 'RCInitAddFunc {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))

   return None

#===============================================================================

def tool_method_add_policy(env, build_ids, input_dict):
   ''' Method Call, Adds RCINIT Policy Function
   Validates input and stores to 'globals' construction environment
   Runs before tool_emitter() function '''

   # 'globals' information saved in the construction environment
   env_rcinit = env[ENV_RCINIT]           # construct env task/function dictionary
   env_rcinit_pol = env[ENV_RCINIT_POL]   # construct env policy utilization dictionary

   # caller python frame of interest
   frame, filename, line_number, function_name, lines, index = inspect.getouterframes(inspect.currentframe())[2]

   # define the layout of the ordered dict, all fields in expected
   # ordering of the fields

   output_dict = OrderedDict()
   output_dict[RCINIT_INFO_NAME] = None
   output_dict[RCINIT_INFO_TYPE] = RCINIT_INFO_POLICY
   output_dict[RCINIT_INFO_HASH] = None
   output_dict[RCINIT_INFO_GROUP] = None
   output_dict[RCINIT_INFO_API] = None
   output_dict[RCINIT_INFO_ENTRY] = None
   output_dict[RCINIT_INFO_POLICY] = None
   output_dict[RCINIT_INFO_DEPENDENCY] = None
   output_dict[RCINIT_INFO_AFFINITY] = None
   output_dict[RCINIT_INFO_STACK] = None
   output_dict[RCINIT_INFO_PRIORITY] = None
   output_text = '..../'+filename.replace('\\','/').lower().replace(env.get('BUILD_ROOT', None).lower()+'/', '')
   output_dict[RCINIT_INFO_DEFINED] = { 'file': output_text, 'line': line_number }

   #read in name
   if not input_dict.has_key(POLICY_NAME):
      tool_error(env, POLICY_NAME + ' required')
   if len(input_dict[POLICY_NAME]) > RCINIT_NAME_MAXLEN:
      tool_error(env, POLICY_NAME + ' name exceeds signifigant length shorten to ' + str(RCINIT_NAME_MAXLEN) + ' ' + input_dict[POLICY_NAME])

	#ensure name is unique
   output_dict[INIT_NAME] = input_dict[POLICY_NAME].lower()
   output_dict[RCINIT_INFO_NAME] = output_dict[INIT_NAME]
   output_dict[RCINIT_INFO_HASH] = '{:#x}'.format(namehash(output_dict[RCINIT_INFO_NAME]))

   # Process input on SCONS Command Options
   if env.GetOption('clean') or env.GetOption('no_exec'):
      tool_debug(env, 'TARGET CLEAN/NO_EXEC RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED
   # Process input on specified BUILD_ID list is None
   ##elif build_ids is None: # WILL BE NONE
   ##   tool_debug(env, 'TARGET NOT SPECIFIED RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
   ##   return None # RETURN, IGNORED
   # Ignore input on specified BUILD_ID not being active
   elif build_ids is not None and not env.IsTargetEnable(build_ids):
      tool_debug(env, 'TARGET NOT ACTIVE RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))
      return None # RETURN, IGNORED

   for threads in env_rcinit[RCINIT_INFO_LIST]:
      if threads.has_key(RCINIT_INFO_NAME) and output_dict[RCINIT_INFO_NAME] == threads[RCINIT_INFO_NAME]:
         tool_error(env, 'Duplicate name {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      if threads.has_key(RCINIT_INFO_HASH) and output_dict[RCINIT_INFO_HASH] == threads[RCINIT_INFO_HASH]:
         tool_error(env, 'Duplicate name hash {:s}'.format(output_dict[RCINIT_INFO_NAME]))

   #read in policy list
   if input_dict.has_key(RCINIT_POLICY_OPTIN):
      if not isinstance(input_dict[RCINIT_POLICY_OPTIN], list):
         tool_error(env, 'Requires valid policy list {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_POLICY_OPTIN] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
      output_dict[RCINIT_INFO_POLICY] = [item.lower() for item in input_dict[RCINIT_POLICY_OPTIN]]
   else:
      output_dict[RCINIT_POLICY_OPTIN] = RCINIT_POLICY_DEFAULT
      output_dict[RCINIT_INFO_POLICY] = RCINIT_POLICY_DEFAULT

   #read in init function if applicable
   if input_dict.has_key(POLICY_ENTRY):
      output_dict[INIT_ENTRY] = input_dict[POLICY_ENTRY]
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
   else:
      output_dict[INIT_ENTRY] = output_dict[INIT_NAME] + '_policy'
      output_dict[RCINIT_INFO_ENTRY] = output_dict[INIT_ENTRY]
      tool_warning(env, POLICY_ENTRY + ' should be tech area supplied, not use a default ' + input_dict[INIT_ENTRY])

   #read in sequence level
   if not input_dict.has_key(RCINIT_SEQUENCE_GROUP):
      tool_error(env, 'Requires group {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   if input_dict[RCINIT_SEQUENCE_GROUP] not in RCINIT_SEQUENCE_GROUP_KEYS.keys():
      tool_error(env, 'Requires valid group {:s}'.format(output_dict[RCINIT_INFO_NAME]))
   output_dict[RCINIT_SEQUENCE_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]
   output_dict[RCINIT_INFO_GROUP] = RCINIT_SEQUENCE_GROUP_KEYS[input_dict[RCINIT_SEQUENCE_GROUP]]

   #init function, no thread type
   output_dict[THREAD_API] = THREAD_API_POLICY
   output_dict[RCINIT_INFO_API] = THREAD_API_POLICY

   #read in stack size
   output_dict[THREAD_STACK] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_STACK] = RCINIT_STKSZ_ZERO

   #read in priority
   output_dict[THREAD_PRIORITY] = RCINIT_OUTPUT_NA
   output_dict[RCINIT_INFO_PRIORITY] = RCINIT_PRIO_INITFN
   output_dict[RCINIT_INFO_PRIORITY_ALIAS] = ''

   #read in cpu affinity
   output_dict[THREAD_AFFINITY] = RCINIT_AFFINITY_ALL
   output_dict[RCINIT_INFO_AFFINITY] = RCINIT_AFFINITY_ALL

   #read in dependencies
   if input_dict.has_key(RCINIT_DEPENDENCIES):
      if not isinstance(input_dict[RCINIT_DEPENDENCIES], list):
         tool_error(env, 'Requires valid dependency list {:s}'.format(output_dict[RCINIT_INFO_NAME]))
      output_dict[RCINIT_DEPENDENCIES] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
      output_dict[RCINIT_INFO_DEPENDENCY] = [item.lower() for item in input_dict[RCINIT_DEPENDENCIES]]
   else:
      #NO DEPENDENCIES
      #Policy func is an exception -- it will always be the first init function
      output_dict[RCINIT_INTERNAL_ORDER] = -1
      output_dict[RCINIT_DEPENDENCIES] = []
      output_dict[RCINIT_INFO_DEPENDENCY] = []

   #if this is a new policy, create dictionary/lists
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      if policy not in env_rcinit_pol[RCINIT_POLICY_DICT].keys():
         env_rcinit_pol[RCINIT_POLICY_DICT][policy] = []
         for i in range(RCINIT_SEQUENCE_GROUP_MAX):
            env_rcinit_pol[RCINIT_POLICY_DICT][policy].append([])
   #add entry to each policy  list
   env_rcinit_pol[RCINIT_POLICY_USE_LIST] = list(set(env_rcinit_pol[RCINIT_POLICY_USE_LIST]) | set(output_dict[RCINIT_POLICY_OPTIN]))
   env_rcinit_pol[RCINIT_NOPOLICY_ORDERED_LIST][int(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)
   for policy in output_dict[RCINIT_POLICY_OPTIN]:
      env_rcinit_pol[RCINIT_POLICY_DICT][policy][int(output_dict[RCINIT_SEQUENCE_GROUP])].append(output_dict)

   #add to environment descriptor
   env_rcinit[RCINIT_INFO_LIST].append(output_dict)
   tool_debug(env, 'RCInitAddPolicy {:s} "{:s}" {:d}'.format(output_dict[RCINIT_INFO_NAME], output_dict[RCINIT_INFO_DEFINED]['file'], output_dict[RCINIT_INFO_DEFINED]['line']))

   return None

#===============================================================================
# Support Functions
#===============================================================================

def tool_error(env, Info):
   ''' FATAL Information, Stops Build '''
   env.PrintError('RCINIT ' + Info)
   raise


def tool_warning(env, Info):
   ''' Non-FATAL Information, Build Continues '''
   env.PrintWarning('RCINIT ' + Info)


def tool_info(env, Info):
   ''' Informative Information, Build Continues '''
   env.PrintInfo('RCINIT ' + Info)


def tool_debug(env, Info):
   ''' Diagnostic Information, Build Continues '''
   env.PrintDebugInfo('rcinit', 'RCINIT ' + Info)


def getFileLocation(env, path, fileToFind):
   ''' Tool Utility Function '''
   for root, dirs, files in os.walk(path):
      for filename in fnmatch.filter(files, fileToFind):
         return os.path.join(root, filename)
   return None


def topological_sort(graph):
   ''' Tool Utility Function '''
   count = {}
   for node in graph:
      count[node] = 0
   for node in graph:
      for successor in graph[node]:
         count[successor] += 1
   ready = [ node for node in graph if count[node] == 0 ]
   result = []
   while ready:
      node = ready.pop(-1)
      result.append(node)

      for successor in graph[node]:
         count[successor] -= 1
         if count[successor] == 0:
            ready.append(successor)
   return result


def namehash(name):
   ''' Tool Utility Function '''
   tmp = 0
   hash = 0
   for i in range(len(name)):
      hash = (hash << 4) + ord(name[i])
      tmp = hash & 0xf0000000
      if tmp != 0:
         hash ^= (tmp >> 24)
      hash &= ~tmp
   return hash

def randomstring(size):
   import string
   import random
   allowed = string.ascii_uppercase # add any other allowed characters here
   randomstring = ''.join([allowed[random.randint(0, len(allowed) - 1)] for x in xrange(size)])
   return randomstring

def roundup(x, y):
   return x if x % y == 0 else x + y - x % y
